"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._isUnavailablePeriodValid = exports._mergeOverlappingShifts = exports._mergeOverlappingShiftsInAvailablePeriods = exports.isConfigurationValid = void 0;
var dayjs_1 = __importDefault(require("dayjs"));
var errors_1 = require("./errors");
/**
 * Check the validity of a configuration for the time-slots service. If the configuration is
 * invalid, an error will be thrown to describe how it's invalid.
 * @throws {TimeSlotsFinderError}
 * @param {TimeSlotsFinderConfiguration} configuration
 * @return {boolean}
 */
function isConfigurationValid(configuration) {
    if (!configuration) {
        throw new errors_1.TimeSlotsFinderError("No configuration defined");
    }
    /* Primitive values */
    _checkPrimitiveValue(configuration);
    /* Worked periods */
    if (!Array.isArray(configuration.availablePeriods)) {
        throw new errors_1.TimeSlotsFinderError("A list of available periods is expected");
    }
    for (var i = 0; i < configuration.availablePeriods.length; i += 1) {
        _isAvailablePeriodValid(configuration.availablePeriods[i], i);
    }
    /* Unworked periods */
    if (configuration.unavailablePeriods != null
        && !Array.isArray(configuration.unavailablePeriods)) {
        throw new errors_1.TimeSlotsFinderError("A list of unavailable periods is expected");
    }
    if (configuration.unavailablePeriods) {
        for (var i = 0; i < configuration.unavailablePeriods.length; i += 1) {
            if (!_isUnavailablePeriodValid(configuration.unavailablePeriods[i])) {
                throw new errors_1.TimeSlotsFinderError("Unavailable period n\u00BA" + (i + 1) + " is invalid");
            }
        }
    }
    return true;
}
exports.isConfigurationValid = isConfigurationValid;
function _checkPrimitiveValue(configuration) {
    if (configuration.timeSlotDuration == null || configuration.timeSlotDuration < 1) {
        throw new errors_1.TimeSlotsFinderError("Slot duration must be at least 1 minute");
    }
    if (!_nullOrBetween(1, 30, configuration.slotStartMinuteStep)) {
        throw new errors_1.TimeSlotsFinderError("Slot start minute step must be contained between 1 and 30");
    }
    if (!_nullOrGreaterThanOrEqualTo(0, configuration.minAvailableTimeBeforeSlot)) {
        throw new errors_1.TimeSlotsFinderError("Time before a slot must be at least 0 minutes");
    }
    if (!_nullOrGreaterThanOrEqualTo(0, configuration.minAvailableTimeAfterSlot)) {
        throw new errors_1.TimeSlotsFinderError("Time after a slot must be at least 0 minutes");
    }
    if (!_nullOrGreaterThanOrEqualTo(0, configuration.minTimeBeforeFirstSlot)) {
        throw new errors_1.TimeSlotsFinderError("The number of minutes before first slot must be 0 or more");
    }
    if (!_nullOrGreaterThanOrEqualTo(1, configuration.maxDaysBeforeLastSlot)) {
        throw new errors_1.TimeSlotsFinderError("The number of days before latest slot must be at least 1");
    }
    _checkTimeZone(configuration.timeZone);
    var minBeforeFirst = configuration.minTimeBeforeFirstSlot;
    var maxBeforeLast = configuration.maxDaysBeforeLastSlot;
    if (minBeforeFirst && maxBeforeLast && (minBeforeFirst / (24 * 60) > maxBeforeLast)) {
        throw new errors_1.TimeSlotsFinderError("The first possible slot will always be after last one possible (see minTimeBeforeFirstSlot and maxDaysBeforeLastSlot)");
    }
    return true;
}
function _checkTimeZone(timeZone) {
    if (!timeZone) {
        throw new errors_1.TimeSlotsFinderError("Missing time zone");
    }
    try {
        dayjs_1.default().tz(timeZone);
    }
    catch (_) {
        throw new errors_1.TimeSlotsFinderError("Invalid time zone: " + timeZone);
    }
}
function _nullOrGreaterThanOrEqualTo(limit, value) {
    return value == null || value >= limit;
}
function _nullOrBetween(min, max, value) {
    return value == null || (value >= min && value <= max);
}
/**
 * Return a reformatted array of availablePeriods without overlapping shifts. Not mutating the
 * originals data.
 * @param {AvailablePeriod[]} availablePeriods The array of availablePeriods to reformat
 * @return {AvailablePeriod[]}
 */
function _mergeOverlappingShiftsInAvailablePeriods(availablePeriods) {
    return availablePeriods.map(function (availablePeriod) {
        var _a;
        return (__assign(__assign({}, availablePeriod), { shifts: _mergeOverlappingShifts((_a = availablePeriod.shifts) !== null && _a !== void 0 ? _a : []) }));
    });
}
exports._mergeOverlappingShiftsInAvailablePeriods = _mergeOverlappingShiftsInAvailablePeriods;
/**
 * Check the validity of a configuration for the time-slots service.
 * @param {Shift[]} shifts The shifts to refactor into non-overlapping shifts.
 * @returns {Shift[]}
 */
function _mergeOverlappingShifts(shifts) {
    if (shifts.length < 2) {
        return __spreadArray([], shifts);
    }
    var sortedShifts = __spreadArray([], shifts).sort(function (a, b) { return a.startTime.localeCompare(b.startTime); });
    for (var i = 0; i < sortedShifts.length - 1; i += 1) {
        if (sortedShifts[i].endTime.localeCompare(sortedShifts[i + 1].startTime) >= 0) {
            if (sortedShifts[i].endTime.localeCompare(sortedShifts[i + 1].endTime) < 0) {
                sortedShifts[i] = {
                    startTime: sortedShifts[i].startTime,
                    endTime: sortedShifts[i + 1].endTime,
                };
            }
            sortedShifts.splice(i + 1, 1);
            /* Come back 1 element to recheck the same shift against the new next one */
            i -= 1;
        }
    }
    return sortedShifts;
}
exports._mergeOverlappingShifts = _mergeOverlappingShifts;
/**
 * Check the validity of a configuration for the time-slots service.
 * @param {Period} period The shifts to refactor into non-overlapping shifts.
 * @returns {boolean}
 */
function _isUnavailablePeriodValid(period) {
    return Boolean(period
        && period.startAt
        && period.endAt
        /* Both have year, or both have not */
        && (period.startAt.year == null) === (period.endAt.year == null)
        && _isPeriodMomentValid(period.startAt)
        && _isPeriodMomentValid(period.endAt)
        /**
         * If the year value isn't specified, endAt can precede startAt, and
         * doing so will set the endAt year value to the following year if needed.
         */
        && (period.startAt.year == null
            /* Using the objectSupport DayJS plugin, types are not up to date */
            || dayjs_1.default(period.startAt).isBefore(dayjs_1.default(period.endAt))));
}
exports._isUnavailablePeriodValid = _isUnavailablePeriodValid;
/**
 * Indicate if a worked period is valid or not. Throws if not valid.
 * @param {AvailablePeriod} availablePeriod The period to check.
 * @param {number} index The index of the worked period in the list.
 * @returns {boolean}
 */
function _isAvailablePeriodValid(availablePeriod, index) {
    if (!Number.isInteger(availablePeriod.isoWeekDay)) {
        throw new errors_1.TimeSlotsFinderError("ISO Weekday must and integer for available period n\u00BA" + (index + 1));
    }
    if (availablePeriod.isoWeekDay < 1 || availablePeriod.isoWeekDay > 7) {
        throw new errors_1.TimeSlotsFinderError("ISO Weekday must be contains between 1 (Monday) and 7 (Sunday) for available period n\u00BA" + (index + 1));
    }
    for (var _i = 0, _a = availablePeriod.shifts; _i < _a.length; _i++) {
        var shift = _a[_i];
        if (!_isShiftValid(shift)) {
            throw new errors_1.TimeSlotsFinderError("Daily shift " + shift.startTime + " - " + shift.endTime + " for available period n\u00BA" + (index + 1) + " is invalid");
        }
    }
    if (_mergeOverlappingShifts(availablePeriod.shifts).length !== availablePeriod.shifts.length) {
        throw new errors_1.TimeSlotsFinderError("Some shifts are overlapping for available period n\u00BA" + (index + 1));
    }
    return true;
}
/**
 * Indicate either if the provided date string is valid or not.
 * @param {PeriodMoment} periodMoment The date object to check.
 * @returns {boolean}
 */
function _isPeriodMomentValid(periodMoment) {
    if (periodMoment.hour == null && periodMoment.minute != null) {
        return false;
    }
    var isYearAndMonthValid = ((periodMoment.year == null || periodMoment.year > 0)
        && periodMoment.month >= 0 && periodMoment.month <= 11);
    if (!isYearAndMonthValid) {
        return false;
    }
    /* The day check depends on month and year */
    var day = dayjs_1.default().month(periodMoment.month);
    if (periodMoment.year) {
        day = day.year(periodMoment.year);
    }
    return (periodMoment.day >= 1 && periodMoment.day <= day.daysInMonth()
        && (periodMoment.hour == null || (periodMoment.hour >= 0 && periodMoment.hour <= 23))
        && (periodMoment.minute == null || (periodMoment.minute >= 0 && periodMoment.minute <= 59)));
}
/**
 * Indicate either if the provided date string is valid or not.
 * @param {Shift} shift The date string to check.
 * @returns {boolean}
 */
function _isShiftValid(shift) {
    var _a = shift.startTime.split(":").map(Number), startHour = _a[0], startMinute = _a[1];
    var _b = shift.endTime.split(":").map(Number), endHour = _b[0], endMinute = _b[1];
    return (shift
        && shift.startTime.match(/^\d{2}:\d{2}$/)
        && shift.endTime.match(/^\d{2}:\d{2}$/)
        && startHour >= 0 && startHour <= 23
        && startMinute >= 0 && startMinute <= 59
        && endHour >= 0 && endHour <= 23
        && endMinute >= 0 && endMinute <= 59
        && shift.endTime.localeCompare(shift.startTime) > 0);
}
