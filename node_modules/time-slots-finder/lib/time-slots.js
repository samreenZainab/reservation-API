"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAvailableTimeSlotsInCalendar = void 0;
var dayjs_1 = __importDefault(require("dayjs"));
var config_management_1 = require("./config-management");
var extractor_1 = require("./events-extractors/extractor");
var errors_1 = require("./errors");
var types_1 = require("./types");
/**
 * Extract available time slots from a calendar. Take a configuration to precise rules used to
 * search availabilities. If the configuration provided is invalid, an error will be thrown.
 * @throws TimeSlotsFinderError
 * @param {TimeSlotsFinderParameters} params
 * @return {TimeSlot[]}
 */
function getAvailableTimeSlotsInCalendar(params) {
    var calendarData = params.calendarData, configuration = params.configuration, from = params.from, to = params.to;
    var _a = params.calendarFormat, calendarFormat = _a === void 0 ? types_1.TimeSlotsFinderCalendarFormat.iCal : _a;
    var usedConfig = _checkSearchParameters(configuration, from, to);
    var unavailablePeriods = usedConfig.unavailablePeriods, timeZone = usedConfig.timeZone;
    var eventList = __spreadArray([], _getUnavailablePeriodAsEvents(unavailablePeriods !== null && unavailablePeriods !== void 0 ? unavailablePeriods : [], timeZone));
    if (calendarData) {
        eventList.push.apply(eventList, extractor_1.extractEventsFromCalendar(timeZone, calendarFormat, calendarData));
    }
    /* Sort by ascending startAt */
    eventList.sort(function (eventA, eventB) { return eventA.startAt.valueOf() - eventB.startAt.valueOf(); });
    var _b = _computeBoundaries(from, to, usedConfig), firstFromMoment = _b.firstFromMoment, lastToMoment = _b.lastToMoment;
    var timeSlots = [];
    var fromMoment = firstFromMoment;
    while (fromMoment.isBefore(lastToMoment)) {
        var weekDayConfig = _getWeekDayConfigForMoment(usedConfig, fromMoment);
        if (weekDayConfig) {
            /* Go through each shift of the week day */
            weekDayConfig.shifts.forEach(function (shift) {
                var _a = _getMomentsFromShift(fromMoment, shift), startAt = _a.startAt, endAt = _a.endAt;
                /* Ensure that shift boundaries don't exceed global boundaries */
                var partialFrom = dayjs_1.default.max(firstFromMoment, startAt);
                var partialTo = dayjs_1.default.min(lastToMoment, endAt);
                if (!partialFrom.isSameOrBefore(partialTo)) {
                    /* That may happen when shift boundaries exceed global ones */
                    return;
                }
                timeSlots.push.apply(timeSlots, _getAvailableTimeSlotsForShift(usedConfig, eventList, partialFrom, partialTo));
            });
        }
        /* Go one day forward: all shifts for this day has been processed (if any) */
        fromMoment = fromMoment.add(1, "day").startOf("day");
    }
    return timeSlots;
}
exports.getAvailableTimeSlotsInCalendar = getAvailableTimeSlotsInCalendar;
function _checkSearchParameters(configuration, from, to) {
    if (!from || !to || from.getTime() > to.getTime()) {
        throw new errors_1.TimeSlotsFinderError("Invalid boundaries for the search");
    }
    var usedConfig = configuration;
    try {
        var formattedPeriods = config_management_1._mergeOverlappingShiftsInAvailablePeriods(configuration.availablePeriods);
        usedConfig = __assign(__assign({}, configuration), { availablePeriods: formattedPeriods });
    }
    catch (_) {
        /* If workedPeriods aren't formatted well and provoke an error, the validation will fail */
    }
    /* Don't go further if configuration is invalid */
    config_management_1.isConfigurationValid(usedConfig);
    return usedConfig;
}
function _computeBoundaries(from, to, configuration) {
    var _a, _b;
    var searchLimitMoment = configuration.maxDaysBeforeLastSlot
        ? dayjs_1.default().tz(configuration.timeZone)
            .add(configuration.maxDaysBeforeLastSlot, "day")
            .endOf("day")
        : null;
    var firstFromMoment = dayjs_1.default.max(dayjs_1.default(from).tz(configuration.timeZone), dayjs_1.default().tz(configuration.timeZone)
        /* `minAvailableTimeBeforeSlot` will be subtract later and it cannot start before now */
        .add((_a = configuration.minAvailableTimeBeforeSlot) !== null && _a !== void 0 ? _a : 0, "minute")
        .add((_b = configuration.minTimeBeforeFirstSlot) !== null && _b !== void 0 ? _b : 0, "minute"));
    var lastToMoment = searchLimitMoment
        ? dayjs_1.default.min(dayjs_1.default(to).tz(configuration.timeZone), searchLimitMoment)
        : dayjs_1.default(to).tz(configuration.timeZone);
    return { firstFromMoment: firstFromMoment, lastToMoment: lastToMoment };
}
function _getWeekDayConfigForMoment(configuration, searchMoment) {
    return (configuration.availablePeriods.find(function (p) { return p.isoWeekDay === searchMoment.isoWeekday(); })
        || null);
}
function _getMomentsFromShift(fromMoment, shift) {
    var startAt = fromMoment.clone();
    startAt = startAt.hour(parseInt(shift.startTime.slice(0, 2), 10));
    startAt = startAt.minute(parseInt(shift.startTime.slice(3), 10));
    var endAt = fromMoment.clone();
    endAt = endAt.hour(parseInt(shift.endTime.slice(0, 2), 10));
    endAt = endAt.minute(parseInt(shift.endTime.slice(3), 10));
    return { startAt: startAt, endAt: endAt };
}
function _getAvailableTimeSlotsForShift(configuration, eventList, from, to) {
    var _a, _b;
    var timeSlots = [];
    var minTimeWindowNeeded = _getMinTimeWindowNeeded(configuration);
    var searchMoment = from.subtract((_a = configuration.minAvailableTimeBeforeSlot) !== null && _a !== void 0 ? _a : 0, "minute");
    var searchEndMoment = to.subtract(configuration.timeSlotDuration + ((_b = configuration.minAvailableTimeBeforeSlot) !== null && _b !== void 0 ? _b : 0), "minute");
    /* Find index of the first event that is not yet ended at searchMoment */
    var eventIndex = eventList.findIndex(function (event) { return event.endAt.isAfter(searchMoment); });
    while (searchMoment.isSameOrBefore(searchEndMoment)) {
        var focusedEvent = (eventIndex >= 0 && eventList[eventIndex]) || null;
        /* Adjust searchMoment according to the slotStartMinuteMultiple param */
        searchMoment = _nextSearchMoment(searchMoment, configuration);
        var freeTimeLimitMoment = searchMoment.add(minTimeWindowNeeded, "minute");
        if (focusedEvent === null || focusedEvent === void 0 ? void 0 : focusedEvent.startAt.isBefore(freeTimeLimitMoment)) {
            /**
             * If first event that is not yet ended start to soon to get a slot at this time,
             * go directly to the end of the event for next search.
             */
            searchMoment = focusedEvent.endAt.clone();
            if (focusedEvent) {
                eventIndex += 1;
            }
        }
        else {
            var _c = _pushNewSlot(searchMoment, configuration), newSearchMoment = _c.newSearchMoment, timeSlot = _c.timeSlot;
            timeSlots.push(timeSlot);
            searchMoment = newSearchMoment;
        }
    }
    return timeSlots;
}
function _getMinTimeWindowNeeded(configuration) {
    var _a, _b;
    return (((_a = configuration.minAvailableTimeBeforeSlot) !== null && _a !== void 0 ? _a : 0)
        + configuration.timeSlotDuration
        + ((_b = configuration.minAvailableTimeAfterSlot) !== null && _b !== void 0 ? _b : 0));
}
function _pushNewSlot(searchMoment, configuration) {
    var _a, _b, _c;
    var startAt = searchMoment
        .add((_a = configuration.minAvailableTimeBeforeSlot) !== null && _a !== void 0 ? _a : 0, "minute");
    var endAt = startAt.add(configuration.timeSlotDuration, "minute");
    var timeSlot = {
        startAt: startAt.toDate(),
        endAt: endAt.toDate(),
        duration: endAt.diff(startAt, "minute"),
    };
    /**
     * We should start searching after just created slot (including free time after it) but before
     * next one free time before it (since the search algorithm take it in account).
     */
    var minutesBeforeNextSearch = Math.max(((_b = configuration.minAvailableTimeAfterSlot) !== null && _b !== void 0 ? _b : 0)
        - ((_c = configuration.minAvailableTimeBeforeSlot) !== null && _c !== void 0 ? _c : 0), 0);
    return {
        newSearchMoment: endAt
            .add(minutesBeforeNextSearch, "minute"),
        timeSlot: timeSlot
    };
}
function _getUnavailablePeriodAsEvents(unavailablePeriods, timeZone) {
    return unavailablePeriods.map(function (unavailablePeriod) {
        /* Transit through string since dayjs.tz with object parsing is bugged */
        var startAtString = dayjs_1.default(unavailablePeriod.startAt).format("YYYY-MM-DD HH:mm");
        var startAt = dayjs_1.default.tz(startAtString, timeZone);
        var endAtString = dayjs_1.default(unavailablePeriod.endAt).format("YYYY-MM-DD HH:mm");
        var endAt = dayjs_1.default.tz(endAtString, timeZone);
        /* If no hours defined, use full days */
        if (unavailablePeriod.startAt.hour == null) {
            startAt = startAt.startOf("day");
        }
        if (unavailablePeriod.endAt.hour == null) {
            endAt = endAt.endOf("day");
        }
        /* Can only happen if no years were defined: push endAt to next year */
        if (endAt.isBefore(startAt)) {
            endAt = endAt.add(1, "year");
        }
        return { startAt: startAt, endAt: endAt };
    });
}
function _nextSearchMoment(moment, configuration) {
    var _a, _b;
    /* Round up to the next minute if second value is not 0 */
    var nextMoment = moment.second() !== 0
        ? moment.startOf("minute").add(1, "minute")
        : moment.clone();
    var slotStartAt = nextMoment.add((_a = configuration.minAvailableTimeBeforeSlot) !== null && _a !== void 0 ? _a : 0, "minute");
    var slotStartMinuteStep = (_b = configuration.slotStartMinuteStep) !== null && _b !== void 0 ? _b : 5;
    var minuteToAdd = (slotStartMinuteStep - (slotStartAt.minute() % slotStartMinuteStep)) % slotStartMinuteStep;
    return nextMoment.add(minuteToAdd, "minute").millisecond(0);
}
